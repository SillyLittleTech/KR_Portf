<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JSON Diagram Visualizer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light;
        --accent: #f97316;
        --accent-muted: #ec4899;
        --accent-soft: rgba(249, 115, 22, 0.08);
        --bg: #f6f7fb;
        --surface: #ffffff;
        --surface-soft: #f9fafc;
        --surface-glass: rgba(255, 255, 255, 0.7);
        --text: #1f2937;
        --text-strong: #111827;
        --text-muted: #6b7280;
        --border: rgba(203, 213, 225, 0.55);
        --node: #ffffff;
        --node-border: rgba(148, 163, 184, 0.35);
        --node-selected: rgba(249, 115, 22, 0.15);
        --node-highlight: rgba(236, 72, 153, 0.18);
        --edge-default: rgba(148, 163, 184, 0.45);
        --edge-highlight: rgba(249, 115, 22, 0.88);
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family:
          "Inter",
          ui-sans-serif,
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          sans-serif;
        color: var(--text);
        display: flex;
        justify-content: center;
        padding: 40px 16px 80px;
        background:
          radial-gradient(
            circle at top left,
            rgba(255, 255, 255, 0.85) 0%,
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(236, 72, 153, 0.08) 0%,
            transparent 55%
          ),
          var(--bg);
        position: relative;
        overflow: hidden;
      }

      body::before {
        content: "";
        position: absolute;
        inset: 0;
        background:
          linear-gradient(90deg, rgba(148, 163, 184, 0.06) 1px, transparent 0)
            repeat-x,
          linear-gradient(0deg, rgba(148, 163, 184, 0.06) 1px, transparent 0)
            repeat-y;
        background-size:
          64px 64px,
          64px 64px;
        pointer-events: none;
        z-index: 0;
      }

      body::after {
        content: "";
        position: absolute;
        inset: -20% -20% 50% 40%;
        background: radial-gradient(
          circle,
          rgba(236, 72, 153, 0.12),
          transparent 60%
        );
        filter: blur(60px);
        pointer-events: none;
        z-index: 0;
      }

      .app {
        position: relative;
        z-index: 1;
        width: min(1200px, 100%);
        display: grid;
        gap: 24px;
      }

      .card {
        background: var(--surface);
        border-radius: 24px;
        padding: 28px;
        border: 1px solid var(--border);
        box-shadow:
          0 18px 35px rgba(15, 23, 42, 0.08),
          0 4px 12px rgba(15, 23, 42, 0.05);
        position: relative;
        overflow: hidden;
        transition:
          transform 0.25s ease,
          box-shadow 0.25s ease;
      }

      .card::before,
      .card::after {
        content: "";
        position: absolute;
        inset: -40% 45% 40% -40%;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.1),
          rgba(249, 115, 22, 0.1)
        );
        transform: rotate(12deg);
        filter: blur(60px);
        opacity: 0.7;
        pointer-events: none;
      }

      .card::after {
        inset: 45% -35% -35% 45%;
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.12),
          rgba(236, 72, 153, 0.08)
        );
        transform: rotate(-8deg);
      }

      .card:hover {
        transform: translateY(-4px);
        box-shadow:
          0 22px 45px rgba(15, 23, 42, 0.14),
          0 8px 18px rgba(15, 23, 42, 0.08);
      }

      h1 {
        margin: 0;
        font-size: clamp(1.8rem, 4vw, 2.4rem);
      }

      p {
        margin: 8px 0 0;
        color: var(--text-muted);
        line-height: 1.6;
      }

      .controls-grid {
        display: grid;
        gap: 18px;
      }

      .columns {
        display: grid;
        gap: 24px;
      }

      @media (min-width: 960px) {
        .columns {
          grid-template-columns: minmax(0, 1fr) minmax(0, 1.4fr);
          align-items: stretch;
        }
      }

      @media (min-width: 960px) {
        .controls-grid {
          grid-template-columns: 1fr;
        }
      }

      .input-card {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .input-summary {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 18px;
      }

      .panel-title {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-strong);
      }

      .panel-subtitle {
        margin: 6px 0 0;
        font-size: 0.92rem;
        color: var(--text-muted);
        max-width: 28rem;
      }

      .hidden-json-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 0.95rem;
        color: var(--text-muted);
      }

      textarea {
        min-height: 240px;
        border-radius: 20px;
        border: 1px solid rgba(209, 213, 219, 0.6);
        background: rgba(255, 255, 255, 0.92);
        color: var(--text-strong);
        padding: 16px;
        font-size: 0.95rem;
        font-family:
          "JetBrains Mono", "SFMono-Regular", Consolas, "Liberation Mono",
          monospace;
        resize: vertical;
        box-shadow: inset 0 1px 2px rgba(148, 163, 184, 0.18);
      }

      input[type="text"],
      input[type="file"],
      select {
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(209, 213, 219, 0.6);
        border-radius: 16px;
        padding: 12px 14px;
        color: var(--text-strong);
        font-size: 0.95rem;
        box-shadow: inset 0 1px 1px rgba(148, 163, 184, 0.16);
      }

      textarea:focus,
      input[type="text"]:focus,
      input[type="file"]:focus,
      select:focus {
        outline: none;
        border-color: rgba(249, 115, 22, 0.45);
        box-shadow:
          0 0 0 3px rgba(249, 115, 22, 0.12),
          inset 0 1px 2px rgba(148, 163, 184, 0.2);
      }

      input[type="file"] {
        padding: 10px 12px;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 10px;
      }

      button.primary {
        border: none;
        border-radius: 999px;
        padding: 12px 24px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        color: #0f172a;
        background: linear-gradient(
          135deg,
          rgba(249, 115, 22, 0.96),
          rgba(236, 72, 153, 0.92)
        );
        box-shadow: 0 12px 24px rgba(236, 72, 153, 0.24);
        transition:
          transform 0.16s ease,
          box-shadow 0.16s ease;
      }

      button.secondary {
        border-radius: 999px;
        border: 1px solid rgba(236, 72, 153, 0.3);
        padding: 12px 24px;
        font-size: 0.95rem;
        color: var(--text);
        background: rgba(236, 72, 153, 0.08);
        cursor: pointer;
        transition: all 0.16s ease;
      }

      button.ghost {
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.28);
        padding: 10px 18px;
        font-size: 0.9rem;
        color: var(--text-muted);
        background: rgba(255, 255, 255, 0.7);
        cursor: pointer;
        transition: all 0.16s ease;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
      }

      button.primary:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 18px 32px rgba(236, 72, 153, 0.3);
      }

      button.secondary:not(:disabled):hover {
        border-color: rgba(249, 115, 22, 0.55);
        background: rgba(249, 115, 22, 0.12);
        color: var(--accent);
      }

      button.ghost:not(:disabled):hover {
        color: var(--accent-muted);
        border-color: rgba(236, 72, 153, 0.32);
        background: rgba(236, 72, 153, 0.12);
      }

      .status {
        margin-top: 16px;
        border-radius: 18px;
        padding: 14px 18px;
        font-size: 0.9rem;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(209, 213, 219, 0.7);
      }

      .status.error {
        border-color: rgba(248, 113, 113, 0.55);
        color: #b91c1c;
      }

      .status.success {
        border-color: rgba(34, 197, 94, 0.35);
        color: #15803d;
      }

      .viewer-card {
        display: grid;
        gap: 22px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.95),
          rgba(248, 250, 252, 0.92)
        );
        border-radius: 24px;
        padding: 28px;
        border: 1px solid rgba(209, 213, 219, 0.55);
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.8),
          0 22px 40px rgba(15, 23, 42, 0.1);
      }

      .viewer-header {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
        justify-content: space-between;
      }

      .search-group {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }

      .search-group input {
        min-width: 220px;
      }

      .diagram-container {
        border-radius: 22px;
        border: 1px dashed rgba(148, 163, 184, 0.28);
        background: linear-gradient(
          180deg,
          rgba(248, 250, 252, 0.8),
          rgba(241, 245, 249, 0.7)
        );
        padding: 24px;
        overflow: auto;
        height: clamp(560px, 70vh, 860px);
        cursor: grab;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }

      .diagram-container.panning {
        cursor: grabbing;
      }

      svg {
        display: block;
        width: 100%;
        height: auto;
      }

      svg [data-node-id] {
        cursor: pointer;
      }

      svg path.tree-edge {
        stroke: url(#edgeGradient);
        stroke-width: 1.6;
        transition:
          stroke 0.25s ease,
          opacity 0.25s ease;
      }

      .tree-node rect {
        transition:
          transform 0.18s ease,
          stroke 0.18s ease,
          fill 0.18s ease;
        transform-origin: center;
      }

      .tree-node:hover rect {
        transform: translateY(-1px);
        stroke: rgba(249, 115, 22, 0.4);
        fill: rgba(255, 255, 255, 0.98);
      }

      .tree-node.hover-path rect {
        transform: translateY(-1px);
        stroke: rgba(249, 115, 22, 0.45);
        fill: rgba(255, 255, 255, 0.98);
      }

      .tree-node.search-hit rect {
        stroke: rgba(236, 72, 153, 0.45);
        stroke-width: 2.1;
        fill: rgba(255, 255, 255, 0.96);
      }

      .tree-node text.node-label,
      .tree-node text.node-meta {
        transition: opacity 0.2s ease;
      }

      .tree-node:hover text.node-meta {
        opacity: 0.95;
      }

      .tree-node.hover-path text.node-meta {
        opacity: 0.95;
      }

      .tree-node.search-hit text.node-label {
        fill: var(--accent);
      }

      svg text.node-label {
        font-size: 13px;
        font-weight: 600;
        fill: var(--text-strong);
      }

      svg text.node-meta {
        font-size: 12px;
        fill: var(--text-muted);
      }

      svg path.hover-path-edge {
        stroke: var(--edge-highlight);
        stroke-width: 2.2;
        stroke-dasharray: 12 14;
        stroke-linecap: round;
        animation: hoverPathFlow 0.9s linear infinite;
      }

      svg g.hover-path rect {
        stroke: var(--accent);
        stroke-width: 2.2;
        stroke-dasharray: 6 4;
        stroke-linecap: round;
        transform: translateY(-1px);
      }

      @keyframes hoverPathFlow {
        to {
          stroke-dashoffset: -26;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .card,
        .viewer-card,
        .tree-node rect,
        svg path.tree-edge,
        button,
        .diagram-container {
          transition: none !important;
        }

        .card:hover,
        .tree-node:hover rect {
          transform: none;
        }

        svg path.hover-path-edge {
          animation: none;
        }
      }

      .node-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(15, 23, 42, 0.35);
        backdrop-filter: blur(14px);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 40;
      }

      .node-modal.is-open {
        opacity: 1;
        pointer-events: auto;
      }

      .node-modal__dialog {
        background: #ffffff;
        border-radius: 28px;
        border: 1px solid rgba(209, 213, 219, 0.65);
        box-shadow: 0 28px 60px rgba(15, 23, 42, 0.14);
        padding: 28px;
        width: min(560px, 90vw);
        display: grid;
        gap: 18px;
        position: relative;
        overflow: hidden;
      }

      .node-modal__dialog::before {
        content: "";
        position: absolute;
        inset: -30% -20% 30% 50%;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.12),
          rgba(249, 115, 22, 0.1)
        );
        filter: blur(50px);
        pointer-events: none;
      }

      .node-modal__dialog > * {
        position: relative;
        z-index: 1;
      }

      .node-modal__header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }

      .node-modal__title {
        margin: 0;
        font-size: 1.25rem;
        color: var(--accent);
      }

      .node-modal__close {
        appearance: none;
        border: none;
        background: rgba(249, 115, 22, 0.12);
        color: var(--accent);
        width: 36px;
        height: 36px;
        border-radius: 999px;
        font-size: 1.25rem;
        cursor: pointer;
        display: grid;
        place-items: center;
      }

      #node-modal-editor {
        min-height: 220px;
        border-radius: 18px;
        border: 1px solid rgba(209, 213, 219, 0.65);
        background: rgba(248, 250, 252, 0.9);
        color: var(--text);
        font-family:
          "JetBrains Mono", "SFMono-Regular", Consolas, "Liberation Mono",
          monospace;
        padding: 16px;
        font-size: 0.95rem;
        resize: vertical;
      }

      .node-modal__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        justify-content: flex-end;
      }

      .json-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(15, 23, 42, 0.35);
        backdrop-filter: blur(14px);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 40;
      }

      .json-modal.is-open {
        opacity: 1;
        pointer-events: auto;
      }

      .json-modal__dialog {
        background: #ffffff;
        border-radius: 28px;
        border: 1px solid rgba(209, 213, 219, 0.65);
        box-shadow: 0 28px 60px rgba(15, 23, 42, 0.14);
        padding: 32px;
        width: min(760px, 92vw);
        display: grid;
        gap: 20px;
        position: relative;
        overflow: hidden;
      }

      .json-modal__dialog::before {
        content: "";
        position: absolute;
        inset: -25% -15% 45% 35%;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.1),
          rgba(249, 115, 22, 0.08)
        );
        filter: blur(60px);
        pointer-events: none;
      }

      .json-modal__dialog > * {
        position: relative;
        z-index: 1;
      }

      .json-modal__header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 18px;
      }

      .json-modal__title {
        margin: 0;
        font-size: 1.25rem;
        color: var(--text-strong);
      }

      .json-modal__subtitle {
        margin: 6px 0 0;
        color: var(--text-muted);
        font-size: 0.95rem;
        max-width: 30rem;
      }

      .json-modal__close {
        appearance: none;
        border: none;
        background: rgba(148, 163, 184, 0.18);
        color: var(--accent);
        width: 40px;
        height: 40px;
        border-radius: 999px;
        font-size: 1.35rem;
        cursor: pointer;
        display: grid;
        place-items: center;
      }

      #json-modal-editor {
        min-height: 340px;
        border-radius: 20px;
        border: 1px solid rgba(209, 213, 219, 0.65);
        background: rgba(248, 250, 252, 0.92);
        color: var(--text-strong);
        font-family:
          "JetBrains Mono", "SFMono-Regular", Consolas, "Liberation Mono",
          monospace;
        padding: 18px;
        font-size: 0.93rem;
        resize: vertical;
        box-shadow: inset 0 1px 2px rgba(148, 163, 184, 0.2);
      }

      .json-modal__actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }

      #node-modal-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 12px;
        border-radius: 999px;
        border: 1px solid rgba(249, 115, 22, 0.4);
        color: var(--accent);
        font-size: 0.75rem;
        background: rgba(249, 115, 22, 0.16);
      }

      .empty-state {
        text-align: center;
        color: var(--text-muted);
        padding: 60px 20px;
      }

      .empty-state h2 {
        margin-bottom: 8px;
        font-size: 1.2rem;
      }

      .empty-state p {
        margin: 0;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/typescript@5.9.2/lib/typescript.js"></script>
  </head>
  <body>
    <main class="app">
      <section class="card">
        <h1 class="font-kiya">Kiya Rose JSON Diagrammer</h1>
        <p>
          Paste, drop, or describe JSON and this tool sketches an interactive
          diagram. Toggle nodes, search paths, and export the structure as
          SVG—no network or build step required.
        </p>
      </section>

      <section class="columns">
        <div class="card input-card">
          <div class="input-summary">
            <div>
              <h2 class="panel-title">Data Source</h2>
              <p class="panel-subtitle">
                Load a TypeScript or JSON data module. Use the advanced editor
                for manual tweaks.
              </p>
            </div>
            <button class="ghost" id="open-json-editor" type="button">
              Advanced JSON Editor
            </button>
          </div>
          <textarea
            id="json-source"
            class="hidden-json-input"
            aria-hidden="true"
            tabindex="-1"
          ></textarea>
          <div class="sidebar-controls">
            <label>
              Load `.json` or `.ts` file
              <input
                id="json-file"
                type="file"
                accept=".json,.ts,.tsx,application/json,text/typescript,text/plain"
              />
            </label>
            <label>
              Root label (optional)
              <input id="root-label" type="text" placeholder="data" />
            </label>
            <label>
              Input mode
              <select id="input-mode">
                <option value="json">JSON</option>
                <option value="ts">TypeScript (data module)</option>
              </select>
            </label>
            <div class="actions">
              <button class="primary" id="render" type="button">
                Render diagram
              </button>
              <button class="secondary" id="clear" type="button">Clear</button>
              <button class="ghost" id="load-sample" type="button">
                Load sample
              </button>
            </div>
          </div>
          <div class="status" id="status" style="display: none"></div>
        </div>

        <div class="card viewer-card">
          <div class="viewer-header">
            <div class="search-group">
              <label>
                Search nodes
                <input
                  id="search"
                  type="text"
                  placeholder="name, email, user[0].id"
                />
              </label>
              <button class="ghost" id="expand-all" type="button">
                Expand all
              </button>
              <button class="ghost" id="collapse-all" type="button">
                Collapse all
              </button>
              <button class="ghost" id="download-svg" type="button" disabled>
                Download SVG
              </button>
              <button class="ghost" id="download-ts" type="button" disabled>
                Download TypeScript
              </button>
            </div>
            <span class="badge" id="stats" hidden></span>
          </div>
          <div class="diagram-container" id="diagram">
            <div class="empty-state" id="empty-state">
              <h2>Waiting for JSON</h2>
              <p>
                Render a diagram to explore objects, arrays, and nested values
                at a glance.
              </p>
            </div>
          </div>
        </div>
      </section>

      <div id="node-modal" class="node-modal" aria-hidden="true">
        <div
          class="node-modal__dialog"
          role="dialog"
          aria-modal="true"
          aria-labelledby="node-modal-title"
        >
          <div class="node-modal__header">
            <h2 class="node-modal__title" id="node-modal-title">
              Node details
            </h2>
            <button
              class="node-modal__close"
              id="node-modal-close"
              type="button"
              aria-label="Close node editor"
            >
              &times;
            </button>
          </div>
          <div id="node-modal-meta"></div>
          <textarea id="node-modal-editor" spellcheck="false"></textarea>
          <div class="node-modal__actions">
            <button class="ghost" id="node-modal-reset" type="button">
              Reset value
            </button>
            <button class="primary" id="node-modal-apply" type="button">
              Save changes
            </button>
          </div>
        </div>
      </div>

      <div id="json-modal" class="json-modal" aria-hidden="true">
        <div
          class="json-modal__dialog"
          role="dialog"
          aria-modal="true"
          aria-labelledby="json-modal-title"
        >
          <div class="json-modal__header">
            <div>
              <h2 class="json-modal__title" id="json-modal-title">
                Advanced JSON Editor
              </h2>
              <p class="json-modal__subtitle">
                Make manual edits to the generated JSON representation. Apply
                changes to re-render the tree.
              </p>
            </div>
            <button
              class="json-modal__close"
              id="json-modal-close"
              type="button"
              aria-label="Close JSON editor"
            >
              &times;
            </button>
          </div>
          <textarea id="json-modal-editor" spellcheck="false"></textarea>
          <div class="json-modal__actions">
            <button class="ghost" id="json-modal-reset" type="button">
              Revert
            </button>
            <button class="primary" id="json-modal-apply" type="button">
              Apply &amp; Render
            </button>
          </div>
        </div>
      </div>
    </main>

    <script>
      const HorizontalSpacing = 200;
      const VerticalSpacing = 120;
      const NodeWidth = 160;
      const NodeHeight = 60;
      const NodeRadius = 18;
      const DiagramPadding = 40;
      const ROOT_KEY = "__root__";

      const jsonInput = document.getElementById("json-source");
      const fileInput = document.getElementById("json-file");
      const rootLabelInput = document.getElementById("root-label");
      const renderButton = document.getElementById("render");
      const clearButton = document.getElementById("clear");
      const loadSampleButton = document.getElementById("load-sample");
      const statusBox = document.getElementById("status");
      const openJsonEditorButton = document.getElementById("open-json-editor");
      const diagramContainer = document.getElementById("diagram");
      const emptyState = document.getElementById("empty-state");
      const searchInput = document.getElementById("search");
      const expandAllButton = document.getElementById("expand-all");
      const collapseAllButton = document.getElementById("collapse-all");
      const downloadSvgButton = document.getElementById("download-svg");
      const downloadTsButton = document.getElementById("download-ts");
      const statsBadge = document.getElementById("stats");
      const nodeModal = document.getElementById("node-modal");
      const nodeModalTitle = document.getElementById("node-modal-title");
      const nodeModalMeta = document.getElementById("node-modal-meta");
      const nodeModalEditor = document.getElementById("node-modal-editor");
      const nodeModalApply = document.getElementById("node-modal-apply");
      const nodeModalReset = document.getElementById("node-modal-reset");
      const nodeModalClose = document.getElementById("node-modal-close");
      const jsonModal = document.getElementById("json-modal");
      const jsonModalEditor = document.getElementById("json-modal-editor");
      const jsonModalApply = document.getElementById("json-modal-apply");
      const jsonModalReset = document.getElementById("json-modal-reset");
      const jsonModalClose = document.getElementById("json-modal-close");

      let dataModel = null;
      let tree = null;
      let nodeIdCounter = 0;
      let collapsed = new Map([[ROOT_KEY, false]]);
      const INITIAL_SCALE = 1.65;
      let panZoom = { x: 0, y: 0, scale: INITIAL_SCALE };
      const MIN_SCALE = 0.1;
      const MAX_SCALE = 6;
      const PAN_SENSITIVITY = 1.6;
      const WHEEL_SENSITIVITY = 0.35;
      let panInitialized = false;
      let isPanning = false;
      let panPointerId = null;
      let panStart = { x: 0, y: 0 };
      let panOrigin = { x: 0, y: 0 };
      let svgElement = null;
      let viewportGroup = null;
      let searchTerm = "";
      let selectedPathKey = null;
      let selectedNodePath = null;
      let selectedNodeId = null;
      let conversionMeta = null;
      let tsSourcePath = null;
      const inputModeSelect = document.getElementById("input-mode");
      let inputMode = inputModeSelect ? inputModeSelect.value : "json";
      const SEARCH_DEBOUNCE_MS = 140;
      let searchDebounceId = null;
      let nodeElements = new Map();
      let edgeElements = new Map();
      let nodeIndex = new Map();
      let hoverNodeGroups = [];
      let hoverEdgePaths = [];

      function showStatus(message, kind = "success") {
        statusBox.textContent = message;
        statusBox.className =
          kind === "error" ? "status error" : "status success";
        statusBox.style.display = "block";
      }

      function clearStatus() {
        statusBox.style.display = "none";
        statusBox.textContent = "";
      }

      function formatType(value) {
        if (value === null) {
          return "null";
        }
        if (Array.isArray(value)) {
          return `array(${value.length})`;
        }
        return typeof value;
      }

      function summariseValue(value) {
        if (value === null) {
          return "null";
        }
        if (Array.isArray(value)) {
          return `Array(${value.length})`;
        }
        if (typeof value === "object") {
          const keys = Object.keys(value);
          return `Object(${keys.length})`;
        }
        if (typeof value === "string") {
          return value.length > 32 ? `${value.slice(0, 32)}…` : value;
        }
        return String(value);
      }

      const PLACEHOLDER_PREFIX = "__DATA_PLACEHOLDER__";
      const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
      const printerSourceFile = ts.createSourceFile(
        "converter.ts",
        "",
        ts.ScriptTarget.Latest,
        false,
        ts.ScriptKind.TS,
      );

      function unwrapLiteral(node) {
        if (!node) {
          return node;
        }
        if (ts.isAsExpression(node) || ts.isTypeAssertionExpression?.(node)) {
          return unwrapLiteral(node.expression);
        }
        if (
          ts.isSatisfiesExpression?.(node) ||
          ts.isNonNullExpression?.(node)
        ) {
          return unwrapLiteral(node.expression);
        }
        if (ts.isParenthesizedExpression(node)) {
          return unwrapLiteral(node.expression);
        }
        return node;
      }

      function evaluateLiteral(node) {
        const literal = unwrapLiteral(node);

        if (ts.isArrayLiteralExpression(literal)) {
          return literal.elements.map((element) => {
            if (ts.isOmittedExpression(element)) {
              throw new Error(
                "Array holes are not supported in exported literals.",
              );
            }
            if (ts.isSpreadElement(element)) {
              throw new Error(
                "Spread elements are not supported in exported arrays.",
              );
            }
            return evaluateLiteral(element);
          });
        }

        if (ts.isObjectLiteralExpression(literal)) {
          const result = {};
          for (const prop of literal.properties) {
            if (!ts.isPropertyAssignment(prop)) {
              throw new Error(
                "Only standard property assignments are supported in exported objects.",
              );
            }

            let key;
            if (ts.isIdentifier(prop.name)) {
              key = prop.name.text;
            } else if (
              ts.isStringLiteralLike(prop.name) ||
              ts.isNumericLiteral(prop.name)
            ) {
              key = prop.name.text;
            } else {
              throw new Error(
                "Unsupported property name in exported object literal.",
              );
            }

            result[key] = evaluateLiteral(prop.initializer);
          }
          return result;
        }

        if (ts.isStringLiteralLike(literal)) {
          return literal.text;
        }

        if (ts.isTemplateExpression(literal)) {
          if (literal.templateSpans.length === 0) {
            return literal.head.text;
          }
          throw new Error(
            "Template expressions with interpolations are not supported.",
          );
        }

        if (ts.isNumericLiteral(literal)) {
          return Number(literal.text);
        }

        if (ts.isPrefixUnaryExpression(literal)) {
          if (
            literal.operator === ts.SyntaxKind.MinusToken &&
            ts.isNumericLiteral(literal.operand)
          ) {
            return -Number(literal.operand.text);
          }
          throw new Error("Unsupported unary expression in exported literal.");
        }

        if (literal.kind === ts.SyntaxKind.TrueKeyword) {
          return true;
        }
        if (literal.kind === ts.SyntaxKind.FalseKeyword) {
          return false;
        }
        if (literal.kind === ts.SyntaxKind.NullKeyword) {
          return null;
        }

        throw new Error(
          "Encountered an unsupported expression while parsing the export literal.",
        );
      }

      function computeBaseIndent(sourceText, valueStart) {
        const lineStart = sourceText.lastIndexOf("\n", valueStart - 1) + 1;
        let indent = "";
        for (let index = lineStart; index < sourceText.length; index += 1) {
          const char = sourceText[index];
          if (char === " " || char === "\t") {
            indent += char;
            continue;
          }
          break;
        }
        return indent;
      }

      function collectTsExports(sourceFile, sourceText) {
        const entries = [];
        const values = {};
        const seen = new Set();

        for (const statement of sourceFile.statements) {
          if (!ts.isVariableStatement(statement)) {
            if (ts.isExportAssignment(statement)) {
              const expression = unwrapLiteral(statement.expression);
              if (
                ts.isArrayLiteralExpression(expression) ||
                ts.isObjectLiteralExpression(expression)
              ) {
                const name = "default";
                if (seen.has(name)) {
                  throw new Error("Duplicate default export detected.");
                }

                const value = evaluateLiteral(expression);
                const valueStart = expression.getStart(sourceFile);
                const valueEnd = expression.getEnd();
                const placeholder = `${PLACEHOLDER_PREFIX}${name}_${valueStart}_${valueEnd}__`;
                const baseIndent = computeBaseIndent(sourceText, valueStart);

                entries.push({
                  name,
                  valueStart,
                  valueEnd,
                  placeholder,
                  baseIndent,
                });
                values[name] = value;
                seen.add(name);
              }
            }
            continue;
          }

          const modifiers = ts.getCombinedModifierFlags(statement);
          if ((modifiers & ts.ModifierFlags.Export) === 0) {
            continue;
          }

          for (const declaration of statement.declarationList.declarations) {
            if (
              !ts.isIdentifier(declaration.name) ||
              !declaration.initializer
            ) {
              continue;
            }

            const name = declaration.name.text;
            if (seen.has(name)) {
              throw new Error(`Duplicate export named \`${name}\` was found.`);
            }

            const literalNode = unwrapLiteral(declaration.initializer);
            if (
              !ts.isArrayLiteralExpression(literalNode) &&
              !ts.isObjectLiteralExpression(literalNode)
            ) {
              continue;
            }

            const value = evaluateLiteral(literalNode);
            const valueStart = literalNode.getStart(sourceFile);
            const valueEnd = literalNode.getEnd();
            const placeholder = `${PLACEHOLDER_PREFIX}${name}_${valueStart}_${valueEnd}__`;
            const baseIndent = computeBaseIndent(sourceText, valueStart);

            entries.push({
              name,
              valueStart,
              valueEnd,
              placeholder,
              baseIndent,
            });
            values[name] = value;
            seen.add(name);
          }
        }

        return { entries, values };
      }

      function buildTemplate(sourceText, entries) {
        const sorted = [...entries].sort((a, b) => a.valueStart - b.valueStart);
        let cursor = 0;
        let template = "";

        for (const entry of sorted) {
          template += sourceText.slice(cursor, entry.valueStart);
          template += entry.placeholder;
          cursor = entry.valueEnd;
        }

        template += sourceText.slice(cursor);
        return template;
      }

      function isIdentifierCandidate(text) {
        return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(text);
      }

      function createLiteralFromValue(value) {
        if (value === null) {
          return ts.factory.createNull();
        }

        if (Array.isArray(value)) {
          const elements = value.map((item) => createLiteralFromValue(item));
          return ts.factory.createArrayLiteralExpression(
            elements,
            elements.length > 0,
          );
        }

        switch (typeof value) {
          case "string":
            return ts.factory.createStringLiteral(value);
          case "number":
            return Number.isFinite(value)
              ? ts.factory.createNumericLiteral(value)
              : ts.factory.createStringLiteral(String(value));
          case "boolean":
            return value ? ts.factory.createTrue() : ts.factory.createFalse();
          case "object": {
            const properties = Object.entries(value).map(([key, item]) => {
              const nameNode = isIdentifierCandidate(key)
                ? ts.factory.createIdentifier(key)
                : ts.factory.createStringLiteral(key);
              return ts.factory.createPropertyAssignment(
                nameNode,
                createLiteralFromValue(item),
              );
            });
            return ts.factory.createObjectLiteralExpression(
              properties,
              properties.length > 0,
            );
          }
          default:
            throw new Error(`Unsupported value type: ${typeof value}`);
        }
      }

      function formatValueForTs(value, baseIndent = "") {
        const literal = createLiteralFromValue(value);
        const printed = printer.printNode(
          ts.EmitHint.Expression,
          literal,
          printerSourceFile,
        );
        const lines = printed.split("\n");

        if (lines.length === 1) {
          return lines[0];
        }

        const formatted = [lines[0]];
        for (let index = 1; index < lines.length; index += 1) {
          const line = lines[index];
          if (line.length === 0) {
            formatted.push(line);
            continue;
          }
          const match = line.match(/^(\s*)(.*)$/);
          const leading = match ? match[1].length : 0;
          const remainder = leading % 4;
          const level = (leading - remainder) / 4;
          const adjustedIndent = `${baseIndent}${"  ".repeat(level)}${remainder > 0 ? " ".repeat(remainder) : ""}`;
          formatted.push(
            `${adjustedIndent}${match ? match[2] : line.trimStart()}`,
          );
        }

        return formatted.join("\n");
      }

      function convertTsSourceToJson(sourceText, sourceName = "module.ts") {
        const scriptKind = sourceName.toLowerCase().endsWith(".tsx")
          ? ts.ScriptKind.TSX
          : ts.ScriptKind.TS;
        const sourceFile = ts.createSourceFile(
          sourceName,
          sourceText,
          ts.ScriptTarget.Latest,
          true,
          scriptKind,
        );

        const { entries, values } = collectTsExports(sourceFile, sourceText);

        if (entries.length === 0) {
          throw new Error(
            "No convertible exported arrays or objects were found in the TypeScript module.",
          );
        }

        const template = buildTemplate(sourceText, entries);
        const meta = {
          version: 1,
          template,
          source: sourceName,
          entries: entries.map(({ name, placeholder, baseIndent }) => ({
            name,
            placeholder,
            baseIndent,
          })),
          generatedAt: new Date().toISOString(),
        };

        return { meta, data: values };
      }

      function convertJsonToTs(meta, data) {
        if (
          !meta ||
          typeof meta !== "object" ||
          !meta.template ||
          !Array.isArray(meta.entries)
        ) {
          throw new Error(
            "Missing conversion metadata. Load a TypeScript module first.",
          );
        }

        let output = meta.template;

        for (const entry of meta.entries) {
          if (!entry || !entry.name || !entry.placeholder) {
            throw new Error("Conversion metadata is malformed.");
          }

          if (!(entry.name in data)) {
            throw new Error(`JSON data is missing export \`${entry.name}\`.`);
          }

          const replacement = formatValueForTs(
            data[entry.name],
            entry.baseIndent ?? "",
          );

          if (!output.includes(entry.placeholder)) {
            throw new Error(
              `Placeholder for export \`${entry.name}\` was not found in the template. The metadata may be out of sync.`,
            );
          }

          output = output.replace(entry.placeholder, replacement);
        }

        return output;
      }

      function cloneData(value) {
        if (value === null || typeof value !== "object") {
          return value;
        }
        if (typeof structuredClone === "function") {
          return structuredClone(value);
        }
        return JSON.parse(JSON.stringify(value));
      }

      function getSerializablePayload() {
        if (conversionMeta) {
          const metaClone = cloneData(conversionMeta);
          const dataClone = cloneData(dataModel);
          if (
            dataClone &&
            typeof dataClone === "object" &&
            !Array.isArray(dataClone)
          ) {
            return { __meta: metaClone, ...dataClone };
          }
          return { __meta: metaClone, value: dataClone };
        }
        return cloneData(dataModel);
      }

      function updateJsonTextarea({ refreshTimestamp = false } = {}) {
        if (conversionMeta && refreshTimestamp) {
          conversionMeta.generatedAt = new Date().toISOString();
        }

        const payload = getSerializablePayload();
        if (typeof payload === "undefined") {
          jsonInput.value = "";
          if (jsonModal.classList.contains("is-open")) {
            jsonModalEditor.value = "";
          }
          return;
        }

        try {
          jsonInput.value = JSON.stringify(payload, null, 2);
          if (jsonModal.classList.contains("is-open")) {
            jsonModalEditor.value = jsonInput.value;
          }
        } catch (error) {
          // Fallback in case of unexpected serialization issues.
          jsonInput.value = "";
        }
      }

      function updateDownloadButtons(hasDiagram) {
        downloadSvgButton.disabled = !hasDiagram;
        downloadTsButton.disabled = !hasDiagram || !conversionMeta;
      }

      function getPathKey(path) {
        if (!path || path.length === 0) {
          return ROOT_KEY;
        }
        return path
          .map((segment) =>
            typeof segment === "number" ? `[${segment}]` : segment,
          )
          .join(".");
      }

      function pathToDisplay(path) {
        if (!path || path.length === 0) {
          return "(root)";
        }
        return path.reduce((acc, segment) => {
          if (typeof segment === "number") {
            return `${acc}[${segment}]`;
          }
          return acc ? `${acc}.${segment}` : segment;
        }, "");
      }

      function formatEditorValue(value) {
        if (typeof value === "string") {
          return value;
        }
        return JSON.stringify(value, null, 2);
      }

      function buildTree(value, label, path, parentPathKey = null) {
        const id = `node-${(nodeIdCounter += 1)}`;
        const pathKey = getPathKey(path);
        let children = [];

        if (Array.isArray(value)) {
          children = value.map((item, index) =>
            buildTree(item, `[${index}]`, [...path, index], pathKey),
          );
        } else if (value && typeof value === "object") {
          children = Object.entries(value).map(([key, item]) =>
            buildTree(item, key, [...path, key], pathKey),
          );
        }

        return {
          id,
          label,
          type: formatType(value),
          summary: summariseValue(value),
          value,
          children,
          path,
          pathKey,
          parentPathKey,
          width: 1,
          x: 0,
          y: 0,
          visibleChildren: [],
        };
      }

      function measure(node) {
        if (!node.children || node.children.length === 0) {
          node.width = 1;
          return node.width;
        }
        let sum = 0;
        for (const child of node.children) {
          sum += measure(child);
        }
        node.width = Math.max(sum, 1);
        return node.width;
      }

      function assignPositions(node, center, depth) {
        node.y = depth * VerticalSpacing;
        const isCollapsed = collapsed.get(node.pathKey) === true;

        if (!node.children || node.children.length === 0 || isCollapsed) {
          node.x = center;
          node.visibleChildren = [];
          return;
        }

        let cursor = center - (node.width * HorizontalSpacing) / 2;
        node.visibleChildren = [];

        for (const child of node.children) {
          const childSpan = child.width * HorizontalSpacing;
          const childCenter = cursor + childSpan / 2;
          assignPositions(child, childCenter, depth + 1);
          node.visibleChildren.push(child);
          cursor += childSpan;
        }

        if (node.visibleChildren.length > 0) {
          const first = node.visibleChildren[0];
          const last = node.visibleChildren[node.visibleChildren.length - 1];
          node.x = (first.x + last.x) / 2;
        } else {
          node.x = center;
        }
      }

      function collectVisibleNodes(node, list = []) {
        list.push(node);
        if (node.visibleChildren) {
          for (const child of node.visibleChildren) {
            collectVisibleNodes(child, list);
          }
        }
        return list;
      }

      function indexTree(node) {
        if (!node) {
          return;
        }
        nodeIndex.set(node.pathKey, node);
        if (node.children) {
          for (const child of node.children) {
            indexTree(child);
          }
        }
      }

      function findNodeByPathKey(node, pathKey) {
        if (!node) {
          return null;
        }
        if (node.pathKey === pathKey) {
          return node;
        }
        if (!node.children) {
          return null;
        }
        for (const child of node.children) {
          const match = findNodeByPathKey(child, pathKey);
          if (match) {
            return match;
          }
        }
        return null;
      }

      function getNodeByPathKeyCached(pathKey) {
        if (!pathKey) {
          return null;
        }
        return nodeIndex.get(pathKey) ?? findNodeByPathKey(tree, pathKey);
      }

      function matchesSearch(node, term) {
        const valueString =
          typeof node.value === "object"
            ? JSON.stringify(node.value)
            : String(node.value);
        const pathString = pathToDisplay(node.path);
        const label = node.label || "";
        const summary = node.summary || "";
        const haystack =
          `${label} ${summary} ${pathString} ${valueString}`.toLowerCase();
        return haystack.includes(term.toLowerCase());
      }

      let transformFrame = null;
      function requestTransformUpdate() {
        if (transformFrame !== null) {
          return;
        }
        transformFrame = requestAnimationFrame(() => {
          transformFrame = null;
          if (!viewportGroup) {
            return;
          }
          viewportGroup.setAttribute(
            "transform",
            `translate(${panZoom.x}, ${panZoom.y}) scale(${panZoom.scale})`,
          );
        });
      }

      function applyTransform() {
        panZoom.scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, panZoom.scale));
        requestTransformUpdate();
      }

      function resetPanZoom() {
        panInitialized = false;
        panZoom = { x: 0, y: 0, scale: INITIAL_SCALE };
        applyTransform();
      }

      function getLocalPoint(event) {
        if (!svgElement || !viewportGroup) {
          return { x: 0, y: 0 };
        }
        const point = svgElement.createSVGPoint();
        point.x = event.clientX;
        point.y = event.clientY;
        const matrix = viewportGroup.getScreenCTM();
        if (!matrix) {
          return { x: 0, y: 0 };
        }
        return point.matrixTransform(matrix.inverse());
      }

      function setupPanZoomHandlers(svg) {
        svg.style.touchAction = "none";

        const handlePointerDown = (event) => {
          const nodeTarget = event.target.closest?.("[data-node-id]");
          const shouldPan =
            event.button === 1 ||
            (event.button === 0 && (event.shiftKey || !nodeTarget));

          if (!shouldPan) {
            return;
          }

          event.preventDefault();
          isPanning = true;
          panPointerId = event.pointerId;
          panStart = { x: event.clientX, y: event.clientY };
          panOrigin = { x: panZoom.x, y: panZoom.y };
          diagramContainer.classList.add("panning");
          svg.setPointerCapture(event.pointerId);
        };

        const handlePointerMove = (event) => {
          if (!isPanning || event.pointerId !== panPointerId) {
            return;
          }
          const dx = (event.clientX - panStart.x) * PAN_SENSITIVITY;
          const dy = (event.clientY - panStart.y) * PAN_SENSITIVITY;
          panZoom.x = panOrigin.x + dx;
          panZoom.y = panOrigin.y + dy;
          applyTransform();
        };

        const handlePointerUp = (event) => {
          if (event.pointerId !== panPointerId) {
            return;
          }
          isPanning = false;
          panPointerId = null;
          diagramContainer.classList.remove("panning");
          try {
            svg.releasePointerCapture(event.pointerId);
          } catch {
            // ignore
          }
        };

        const handleWheel = (event) => {
          if (!viewportGroup) {
            return;
          }
          event.preventDefault();
          const delta = event.deltaY * WHEEL_SENSITIVITY;
          const scaleFactor = Math.exp(-delta / 180);
          const newScale = Math.min(
            MAX_SCALE,
            Math.max(MIN_SCALE, panZoom.scale * scaleFactor),
          );
          const localPoint = getLocalPoint(event);

          panZoom.x =
            localPoint.x -
            (localPoint.x - panZoom.x) * (newScale / panZoom.scale);
          panZoom.y =
            localPoint.y -
            (localPoint.y - panZoom.y) * (newScale / panZoom.scale);
          panZoom.scale = newScale;
          applyTransform();
        };

        svg.addEventListener("pointerdown", handlePointerDown);
        svg.addEventListener("pointermove", handlePointerMove);
        svg.addEventListener("pointerup", handlePointerUp);
        svg.addEventListener("pointercancel", handlePointerUp);
        svg.addEventListener("wheel", handleWheel, { passive: false });
      }

      function renderTree(root) {
        if (!root) {
          clearHoverPath();
          nodeElements = new Map();
          edgeElements = new Map();
          diagramContainer.innerHTML = "";
          diagramContainer.appendChild(emptyState);
          emptyState.hidden = false;
          svgElement = null;
          viewportGroup = null;
          updateDownloadButtons(false);
          statsBadge.hidden = true;
          if (nodeModal.classList.contains("is-open")) {
            closeNodeModal();
            clearStatus();
          } else {
            highlightSelected(null);
            selectedPathKey = null;
            selectedNodePath = null;
            selectedNodeId = null;
          }
          applySearchFilter();
          return;
        }

        measure(root);
        clearHoverPath();
        nodeElements = new Map();
        edgeElements = new Map();
        assignPositions(root, 0, 0);
        const nodes = collectVisibleNodes(root, []);

        const xs = nodes.map((node) => node.x);
        const ys = nodes.map((node) => node.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        const width = Math.max(
          960,
          maxX - minX + NodeWidth + DiagramPadding * 2,
        );
        const height = Math.max(
          640,
          maxY - minY + NodeHeight + DiagramPadding * 2,
        );

        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg",
        );
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
        svg.style.minWidth = "100%";
        svg.style.minHeight = "100%";

        const defs = document.createElementNS(svg.namespaceURI, "defs");
        const edgeGradient = document.createElementNS(
          svg.namespaceURI,
          "linearGradient",
        );
        edgeGradient.setAttribute("id", "edgeGradient");
        edgeGradient.setAttribute("x1", "0%");
        edgeGradient.setAttribute("y1", "0%");
        edgeGradient.setAttribute("x2", "100%");
        edgeGradient.setAttribute("y2", "100%");
        edgeGradient.setAttribute("gradientUnits", "objectBoundingBox");

        const edgeStop1 = document.createElementNS(svg.namespaceURI, "stop");
        edgeStop1.setAttribute("offset", "0%");
        edgeStop1.setAttribute("stop-color", "rgba(148, 163, 184, 0.7)");

        const edgeStop2 = document.createElementNS(svg.namespaceURI, "stop");
        edgeStop2.setAttribute("offset", "60%");
        edgeStop2.setAttribute("stop-color", "rgba(236, 72, 153, 0.55)");

        const edgeStop3 = document.createElementNS(svg.namespaceURI, "stop");
        edgeStop3.setAttribute("offset", "100%");
        edgeStop3.setAttribute("stop-color", "rgba(249, 115, 22, 0.6)");

        edgeGradient.append(edgeStop1, edgeStop2, edgeStop3);
        defs.append(edgeGradient);

        svg.appendChild(defs);

        const viewport = document.createElementNS(svg.namespaceURI, "g");
        svg.appendChild(viewport);
        viewportGroup = viewport;

        const edgesGroup = document.createElementNS(svg.namespaceURI, "g");
        edgesGroup.setAttribute("fill", "none");
        edgesGroup.setAttribute("stroke", "var(--edge-default)");
        edgesGroup.setAttribute("stroke-width", "1.6");
        viewport.appendChild(edgesGroup);

        const nodesGroup = document.createElementNS(svg.namespaceURI, "g");
        viewport.appendChild(nodesGroup);

        for (const node of nodes) {
          if (!node.visibleChildren || node.visibleChildren.length === 0) {
            continue;
          }
          for (const child of node.visibleChildren) {
            const path = document.createElementNS(svg.namespaceURI, "path");
            const startX = node.x - minX + DiagramPadding + NodeWidth / 2;
            const startY = node.y - minY + DiagramPadding + NodeHeight;
            const endX = child.x - minX + DiagramPadding + NodeWidth / 2;
            const endY = child.y - minY + DiagramPadding;
            const controlOffset = (endY - startY) / 2;
            const d = `M ${startX} ${startY} C ${startX} ${startY + controlOffset}, ${endX} ${endY - controlOffset}, ${endX} ${endY}`;
            path.setAttribute("d", d);
            const edgeKey = `${node.pathKey}->${child.pathKey}`;
            path.dataset.edge = "true";
            path.dataset.from = node.pathKey;
            path.dataset.to = child.pathKey;
            path.classList.add("tree-edge");
            path.setAttribute("stroke", "url(#edgeGradient)");
            edgeElements.set(edgeKey, path);
            edgesGroup.appendChild(path);
          }
        }

        for (const node of nodes) {
          const group = document.createElementNS(svg.namespaceURI, "g");
          group.dataset.nodeId = node.id;
          group.dataset.pathKey = node.pathKey;
          group.dataset.parentPathKey = node.parentPathKey ?? "";
          group.classList.add("tree-node");
          const x = node.x - minX + DiagramPadding;
          const y = node.y - minY + DiagramPadding;

          const rect = document.createElementNS(svg.namespaceURI, "rect");
          rect.setAttribute("x", `${x}`);
          rect.setAttribute("y", `${y}`);
          rect.setAttribute("rx", `${NodeRadius}`);
          rect.setAttribute("ry", `${NodeRadius}`);
          rect.setAttribute("width", `${NodeWidth}`);
          rect.setAttribute("height", `${NodeHeight}`);
          rect.setAttribute(
            "fill",
            collapsed.get(node.pathKey)
              ? "rgba(148, 163, 184, 0.12)"
              : "var(--node)",
          );
          rect.setAttribute("stroke", "var(--node-border)");
          rect.setAttribute("stroke-width", "1.3");
          group.appendChild(rect);

          const label = document.createElementNS(svg.namespaceURI, "text");
          label.setAttribute("x", `${x + 16}`);
          label.setAttribute("y", `${y + 26}`);
          label.setAttribute("class", "node-label");
          label.textContent = node.label || "(root)";
          group.appendChild(label);

          const summary = document.createElementNS(svg.namespaceURI, "text");
          summary.setAttribute("x", `${x + 16}`);
          summary.setAttribute("y", `${y + 46}`);
          summary.setAttribute("class", "node-meta");
          summary.textContent = `${node.type} • ${node.summary}`;
          group.appendChild(summary);

          if (node.children && node.children.length > 0) {
            const toggle = document.createElementNS(svg.namespaceURI, "text");
            toggle.setAttribute("x", `${x + NodeWidth - 22}`);
            toggle.setAttribute("y", `${y + 24}`);
            toggle.setAttribute("fill", "var(--accent)");
            toggle.setAttribute("font-size", "16");
            toggle.setAttribute(
              "font-family",
              "Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
            );
            toggle.textContent = collapsed.get(node.pathKey) ? "+" : "−";
            toggle.classList.add("toggle-icon");
            group.appendChild(toggle);
          }

          group.addEventListener("click", (event) => {
            event.stopPropagation();
            setSelectedNode(node);
          });

          group.addEventListener("dblclick", (event) => {
            event.stopPropagation();
            toggleNode(node.pathKey);
          });

          group.addEventListener("mouseenter", () => {
            highlightHoverPath(node.pathKey);
          });

          group.addEventListener("mouseleave", () => {
            clearHoverPath();
          });

          nodesGroup.appendChild(group);
          nodeElements.set(node.pathKey, group);
        }

        diagramContainer.innerHTML = "";
        diagramContainer.appendChild(svg);
        emptyState.hidden = true;
        svgElement = svg;
        diagramContainer.classList.remove("panning");
        setupPanZoomHandlers(svg);

        if (!panInitialized) {
          const containerWidth = diagramContainer.clientWidth || width;
          const containerHeight = diagramContainer.clientHeight || height;
          panZoom.scale = INITIAL_SCALE;
          const scaledWidth = width * panZoom.scale;
          const scaledHeight = height * panZoom.scale;
          panZoom.x = (containerWidth - scaledWidth) / 2;
          panZoom.y = Math.max(48, (containerHeight - scaledHeight) / 2);
          panInitialized = true;
        }

        applyTransform();

        const totalNodes = nodes.length;
        const depth =
          Math.max(...nodes.map((node) => node.y)) / VerticalSpacing + 1;
        statsBadge.textContent = `${totalNodes} node${totalNodes === 1 ? "" : "s"} • depth ${Math.round(depth)}`;
        statsBadge.hidden = false;

        restoreSelection();
        updateDownloadButtons(true);
        applySearchFilter();
      }

      function updateModalContent(node) {
        nodeModalTitle.textContent = node.label || "Root";
        nodeModalMeta.textContent = "";
        const badge = document.createElement("span");
        badge.className = "badge";
        badge.textContent = node.type;
        const pathSpan = document.createElement("span");
        pathSpan.style.color = "var(--text-muted)";
        pathSpan.style.marginLeft = "12px";
        pathSpan.style.fontSize = "0.85rem";
        pathSpan.textContent = pathToDisplay(node.path);
        nodeModalMeta.appendChild(badge);
        nodeModalMeta.appendChild(pathSpan);
        nodeModalEditor.value = formatEditorValue(node.value);
      }

      function highlightSelected(nodeId) {
        if (!svgElement) {
          return;
        }
        svgElement.querySelectorAll("[data-node-id]").forEach((group) => {
          const rect = group.querySelector("rect");
          if (!rect) {
            return;
          }
          const pathKey = group.dataset.pathKey;
          if (nodeId && group.dataset.nodeId === nodeId) {
            rect.setAttribute("fill", "var(--node-selected)");
            rect.setAttribute("stroke", "var(--accent-muted)");
          } else {
            rect.setAttribute(
              "fill",
              collapsed.get(pathKey) ? "rgba(15, 23, 42, 0.82)" : "var(--node)",
            );
            rect.setAttribute("stroke", "var(--node-border)");
          }
        });
      }

      function clearHoverPath() {
        for (const group of hoverNodeGroups) {
          group.classList.remove("hover-path");
        }
        hoverNodeGroups = [];

        for (const edge of hoverEdgePaths) {
          edge.classList.remove("hover-path-edge");
        }
        hoverEdgePaths = [];
      }

      function applyHoverStylesToNode(group) {
        group.classList.add("hover-path");
        hoverNodeGroups.push(group);
      }

      function applyHoverStylesToEdge(edge) {
        edge.classList.add("hover-path-edge");
        hoverEdgePaths.push(edge);
      }

      function highlightHoverPath(pathKey) {
        if (!tree || !pathKey) {
          clearHoverPath();
          return;
        }

        const targetNode = getNodeByPathKeyCached(pathKey);
        if (!targetNode) {
          clearHoverPath();
          return;
        }

        clearHoverPath();

        const chain = [];
        let current = targetNode;
        while (current) {
          chain.unshift(current.pathKey);
          if (!current.parentPathKey) {
            break;
          }
          current = getNodeByPathKeyCached(current.parentPathKey);
        }

        for (const key of chain) {
          const group = nodeElements.get(key);
          if (group) {
            applyHoverStylesToNode(group);
          }
        }

        for (let index = 0; index < chain.length - 1; index += 1) {
          const edgeKey = `${chain[index]}->${chain[index + 1]}`;
          const edge = edgeElements.get(edgeKey);
          if (edge) {
            applyHoverStylesToEdge(edge);
          }
        }
      }

      function applySearchFilter() {
        const term = searchTerm.trim().toLowerCase();
        if (!nodeElements || nodeElements.size === 0) {
          return;
        }

        nodeElements.forEach((group, pathKey) => {
          if (!group) {
            return;
          }
          if (!term) {
            group.classList.remove("search-hit");
            return;
          }

          const node = getNodeByPathKeyCached(pathKey);
          if (!node) {
            group.classList.remove("search-hit");
            return;
          }

          const match = matchesSearch(node, term);
          group.classList.toggle("search-hit", match);
        });
      }

      function openNodeModal(node) {
        selectedPathKey = node.pathKey;
        selectedNodePath = [...node.path];
        selectedNodeId = node.id;
        updateModalContent(node);
        nodeModal.setAttribute("aria-hidden", "false");
        nodeModal.classList.add("is-open");
        highlightSelected(node.id);
        requestAnimationFrame(() => {
          nodeModalEditor.focus({ preventScroll: true });
        });
      }

      function closeNodeModal() {
        nodeModal.classList.remove("is-open");
        nodeModal.setAttribute("aria-hidden", "true");
        highlightSelected(null);
        selectedPathKey = null;
        selectedNodePath = null;
        selectedNodeId = null;
        clearHoverPath();
      }

      function openJsonModal() {
        if (!jsonModal) {
          return;
        }
        jsonModalEditor.value = jsonInput.value;
        jsonModal.classList.add("is-open");
        jsonModal.setAttribute("aria-hidden", "false");
        requestAnimationFrame(() => {
          jsonModalEditor.focus({ preventScroll: true });
        });
      }

      function closeJsonModal() {
        if (!jsonModal) {
          return;
        }
        jsonModal.classList.remove("is-open");
        jsonModal.setAttribute("aria-hidden", "true");
      }

      function setSelectedNode(node) {
        openNodeModal(node);
      }

      function restoreSelection() {
        if (!selectedPathKey || !tree) {
          if (nodeModal.classList.contains("is-open")) {
            closeNodeModal();
            clearStatus();
          } else {
            highlightSelected(null);
            selectedNodeId = null;
            selectedNodePath = null;
          }
          return;
        }
        const node = findNodeByPathKey(tree, selectedPathKey);
        if (node) {
          selectedNodeId = node.id;
          selectedNodePath = [...node.path];
          if (nodeModal.classList.contains("is-open")) {
            updateModalContent(node);
          }
          highlightSelected(node.id);
        } else {
          if (nodeModal.classList.contains("is-open")) {
            closeNodeModal();
            clearStatus();
          } else {
            highlightSelected(null);
            selectedPathKey = null;
            selectedNodeId = null;
            selectedNodePath = null;
          }
        }
      }

      function toggleNode(pathKey) {
        if (pathKey === ROOT_KEY) {
          return;
        }
        const current = collapsed.get(pathKey) === true;
        collapsed.set(pathKey, !current);
        renderTree(tree);
      }

      function expandAllNodes() {
        collapsed = new Map([[ROOT_KEY, false]]);
        renderTree(tree);
      }

      function collapseAllNodes() {
        if (!tree) {
          return;
        }
        collapsed = new Map([[ROOT_KEY, false]]);
        const queue = [...tree.children];
        while (queue.length > 0) {
          const node = queue.shift();
          if (!node) {
            continue;
          }
          if (node.children && node.children.length > 0) {
            collapsed.set(node.pathKey, true);
            queue.push(...node.children);
          }
        }
        renderTree(tree);
      }

      function pruneCollapsedForPath(pathKey) {
        if (!pathKey) {
          return;
        }
        for (const key of [...collapsed.keys()]) {
          if (key === pathKey) {
            continue;
          }
          if (key.startsWith(`${pathKey}.`)) {
            collapsed.delete(key);
          }
        }
      }

      function updateDataModel(path, newValue) {
        if (!path || path.length === 0) {
          dataModel = newValue;
          return;
        }
        let target = dataModel;
        for (let index = 0; index < path.length - 1; index += 1) {
          const segment = path[index];
          target =
            typeof segment === "number" ? target[segment] : target[segment];
        }
        const last = path[path.length - 1];
        if (typeof last === "number") {
          target[last] = newValue;
        } else {
          target[last] = newValue;
        }
      }

      function parseEditorValue(rawValue, currentValue) {
        const trimmed = rawValue.trim();
        if (trimmed === "") {
          return "";
        }
        try {
          return JSON.parse(rawValue);
        } catch (error) {
          if (
            Array.isArray(currentValue) ||
            (currentValue && typeof currentValue === "object")
          ) {
            throw new Error(
              "Provide valid JSON for objects or arrays (use double quotes).",
            );
          }
          return rawValue;
        }
      }

      function commitNodeChange(
        pathKey,
        editorValue,
        { showStatusMessage = false } = {},
      ) {
        if (!tree) {
          return false;
        }
        const node = findNodeByPathKey(tree, pathKey);
        if (!node) {
          if (showStatusMessage) {
            showStatus("Selected node is no longer available.", "error");
          }
          return false;
        }

        let newValue;
        try {
          newValue = parseEditorValue(editorValue, node.value);
        } catch (error) {
          if (showStatusMessage) {
            showStatus(error.message, "error");
          }
          return false;
        }

        if (node.path.length === 0) {
          collapsed = new Map([[ROOT_KEY, false]]);
        } else {
          pruneCollapsedForPath(node.pathKey);
        }

        updateDataModel(node.path, newValue);
        updateJsonTextarea({ refreshTimestamp: true });
        rebuildTree({ preserveSelection: true });

        if (nodeModal.classList.contains("is-open")) {
          const refreshed = findNodeByPathKey(tree, pathKey);
          if (refreshed) {
            selectedNodeId = refreshed.id;
            selectedNodePath = [...refreshed.path];
            updateModalContent(refreshed);
            highlightSelected(refreshed.id);
          } else {
            closeNodeModal();
            clearStatus();
          }
        }

        if (showStatusMessage) {
          showStatus("Node updated.", "success");
        }

        return true;
      }

      function rebuildTree({
        preserveSelection = true,
        preserveCollapsed = true,
        resetPan = false,
      } = {}) {
        if (dataModel === null || typeof dataModel === "undefined") {
          renderTree(null);
          return;
        }
        if (!preserveCollapsed) {
          collapsed = new Map([[ROOT_KEY, false]]);
        }
        if (!preserveSelection) {
          if (nodeModal.classList.contains("is-open")) {
            closeNodeModal();
            clearStatus();
          } else {
            selectedPathKey = null;
            selectedNodePath = null;
            selectedNodeId = null;
          }
        }
        if (resetPan) {
          resetPanZoom();
        }

        nodeIdCounter = 0;
        tree = buildTree(
          dataModel,
          rootLabelInput.value.trim() || "root",
          [],
          null,
        );
        nodeIndex = new Map();
        indexTree(tree);
        renderTree(tree);
      }

      function renderFromInput() {
        clearStatus();
        const rawText = jsonInput.value.trim();
        if (!rawText) {
          showStatus(
            `Provide ${inputMode === "ts" ? "TypeScript" : "JSON"} input to render a diagram.`,
            "error",
          );
          return false;
        }

        if (inputMode === "ts") {
          try {
            const sourceName = tsSourcePath || "module.ts";
            const { meta, data } = convertTsSourceToJson(rawText, sourceName);
            conversionMeta = meta;
            tsSourcePath = meta.source || sourceName;
            dataModel = cloneData(data);
            collapsed = new Map([[ROOT_KEY, false]]);
            updateJsonTextarea({ refreshTimestamp: false });
            rebuildTree({
              preserveSelection: false,
              preserveCollapsed: false,
              resetPan: true,
            });
            showStatus(
              `Converted ${tsSourcePath || "module.ts"} to JSON.`,
              "success",
            );
            return true;
          } catch (error) {
            renderTree(null);
            updateDownloadButtons(false);
            showStatus(
              error instanceof Error ? error.message : String(error),
              "error",
            );
            return false;
          }
        }

        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch (error) {
          showStatus("Input is not valid JSON.", "error");
          return false;
        }

        if (
          parsed &&
          typeof parsed === "object" &&
          !Array.isArray(parsed) &&
          parsed.__meta &&
          parsed.__meta.template
        ) {
          conversionMeta = parsed.__meta;
          tsSourcePath = conversionMeta.source || tsSourcePath;
          const { __meta, ...rest } = parsed;
          dataModel = Object.keys(rest).length > 0 ? rest : {};
        } else {
          conversionMeta = null;
          tsSourcePath = null;
          dataModel = parsed;
        }

        collapsed = new Map([[ROOT_KEY, false]]);
        updateJsonTextarea({ refreshTimestamp: false });
        rebuildTree({
          preserveSelection: false,
          preserveCollapsed: false,
          resetPan: true,
        });
        showStatus("Diagram generated successfully.", "success");
        return true;
      }

      function clearAll() {
        dataModel = null;
        tree = null;
        conversionMeta = null;
        tsSourcePath = null;
        jsonInput.value = "";
        if (inputModeSelect) {
          inputModeSelect.value = "json";
        }
        inputMode = "json";
        collapsed = new Map([[ROOT_KEY, false]]);
        selectedPathKey = null;
        selectedNodePath = null;
        selectedNodeId = null;
        panInitialized = false;
        resetPanZoom();
        renderTree(null);
        clearStatus();
        if (jsonModal.classList.contains("is-open")) {
          closeJsonModal();
        }
        if (searchDebounceId) {
          clearTimeout(searchDebounceId);
          searchDebounceId = null;
        }
      }

      function loadSample() {
        const sample = {
          name: "Kiya Rose",
          location: {
            city: "Altoona",
            state: "PA",
            timezone: "America/New_York",
          },
          projects: [
            {
              title: "SillyLittleFiles",
              stack: ["ProtonVPN", "OpenVPN", "JavaScript"],
            },
            {
              title: "Enterprise Virtualization Project",
              stack: ["HPE", "Windows Server", "VMWare", "ILO"],
            },
          ],
          skills: {
            core: ["Information Technology", "Customer Service", "Research"],
            developing: ["Medical Coding", "Health Informatics"],
          },
          socials: [
            { label: "GitHub", url: "https://github.com/kiyarose" },
            { label: "LinkedIn", url: "https://linkedin.com/in/kiyarose" },
          ],
        };
        if (inputModeSelect) {
          inputModeSelect.value = "json";
        }
        inputMode = "json";
        conversionMeta = null;
        tsSourcePath = null;
        dataModel = cloneData(sample);
        collapsed = new Map([[ROOT_KEY, false]]);
        selectedPathKey = null;
        selectedNodePath = null;
        selectedNodeId = null;
        rootLabelInput.value = "portfolio";
        updateJsonTextarea({ refreshTimestamp: false });
        rebuildTree({
          preserveSelection: false,
          preserveCollapsed: false,
          resetPan: true,
        });
        showStatus("Loaded sample portfolio data.", "success");
      }

      function downloadSvg() {
        if (!svgElement) {
          return;
        }
        const clone = svgElement.cloneNode(true);
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(clone);
        downloadText("json-diagram.svg", svgString, "image/svg+xml");
      }

      function downloadText(filename, text, mimeType = "text/plain") {
        const blob = new Blob([text], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      }

      fileInput.addEventListener("change", (event) => {
        const file = event.target.files?.[0];
        if (!file) {
          return;
        }
        const extension = file.name.split(".").pop()?.toLowerCase();
        if (extension === "ts" || extension === "tsx") {
          if (inputModeSelect) {
            inputModeSelect.value = "ts";
          }
          inputMode = "ts";
          tsSourcePath = file.name;
        } else {
          if (inputModeSelect) {
            inputModeSelect.value = "json";
          }
          inputMode = "json";
          tsSourcePath = null;
        }
        const reader = new FileReader();
        reader.onload = () => {
          jsonInput.value = String(reader.result ?? "");
          renderFromInput();
        };
        reader.readAsText(file);
      });

      if (inputModeSelect) {
        inputModeSelect.addEventListener("change", () => {
          inputMode = inputModeSelect.value;
        });
      }

      renderButton.addEventListener("click", renderFromInput);
      clearButton.addEventListener("click", clearAll);
      loadSampleButton.addEventListener("click", loadSample);
      expandAllButton.addEventListener("click", () => {
        expandAllNodes();
      });
      collapseAllButton.addEventListener("click", () => {
        collapseAllNodes();
      });
      downloadSvgButton.addEventListener("click", downloadSvg);
      downloadTsButton.addEventListener("click", () => {
        if (!conversionMeta) {
          showStatus(
            "No TypeScript metadata available. Load a TypeScript module first.",
            "error",
          );
          return;
        }
        try {
          const targetData =
            dataModel &&
            typeof dataModel === "object" &&
            !Array.isArray(dataModel)
              ? dataModel
              : { value: dataModel };
          const tsText = convertJsonToTs(conversionMeta, targetData);
          const baseCandidate =
            tsSourcePath || conversionMeta.source || "data.ts";
          const baseName = baseCandidate.split(/[\\/]/).pop() || "data.ts";
          const sanitized = baseName.replace(/[\s]+/g, "-");
          const filename = sanitized.match(/\.tsx?$/)
            ? sanitized.replace(/\.tsx?$/, ".ts")
            : `${sanitized}.ts`;
          downloadText(filename, tsText, "text/typescript");
          showStatus(`Exported ${filename}.`, "success");
        } catch (error) {
          showStatus(
            error instanceof Error ? error.message : String(error),
            "error",
          );
        }
      });

      searchInput.addEventListener("input", () => {
        searchTerm = searchInput.value.trim();
        if (searchDebounceId) {
          clearTimeout(searchDebounceId);
        }
        searchDebounceId = setTimeout(() => {
          searchDebounceId = null;
          applySearchFilter();
        }, SEARCH_DEBOUNCE_MS);
      });

      if (openJsonEditorButton) {
        openJsonEditorButton.addEventListener("click", () => {
          openJsonModal();
        });
      }

      jsonModalApply.addEventListener("click", () => {
        jsonInput.value = jsonModalEditor.value;
        const succeeded = renderFromInput();
        if (succeeded) {
          closeJsonModal();
        }
      });

      jsonModalReset.addEventListener("click", () => {
        jsonModalEditor.value = jsonInput.value;
        clearStatus();
      });

      jsonModalClose.addEventListener("click", () => {
        closeJsonModal();
      });

      jsonModal.addEventListener("click", (event) => {
        if (event.target === jsonModal) {
          closeJsonModal();
        }
      });

      nodeModalApply.addEventListener("click", () => {
        if (!selectedPathKey) {
          showStatus("Select a node before applying changes.", "error");
          return;
        }
        commitNodeChange(selectedPathKey, nodeModalEditor.value, {
          showStatusMessage: true,
        });
      });

      nodeModalReset.addEventListener("click", () => {
        if (!tree || !selectedPathKey) {
          return;
        }
        const node = findNodeByPathKey(tree, selectedPathKey);
        if (node) {
          updateModalContent(node);
        }
        clearStatus();
      });

      nodeModalClose.addEventListener("click", () => {
        closeNodeModal();
        clearStatus();
      });

      nodeModal.addEventListener("click", (event) => {
        if (event.target === nodeModal) {
          closeNodeModal();
          clearStatus();
        }
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && nodeModal.classList.contains("is-open")) {
          closeNodeModal();
          clearStatus();
        }
        if (event.key === "Escape" && jsonModal.classList.contains("is-open")) {
          closeJsonModal();
        }
      });

      diagramContainer.addEventListener("click", () => {
        if (nodeModal.classList.contains("is-open")) {
          closeNodeModal();
          clearStatus();
        }
      });

      diagramContainer.addEventListener("mouseleave", () => {
        clearHoverPath();
      });

      clearAll();
    </script>
  </body>
</html>
